name: Bootstrap Kubernetes Cluster

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Initialize Kubernetes Cluster"]
    types:
      - completed

jobs:
  bootstrap:
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Create kubeconfig for external access
      run: |
        mkdir -p ~/.kube
        
        # Create kubeconfig that skips TLS verification for the public IP
        cat > ~/.kube/config << EOF
        apiVersion: v1
        clusters:
        - cluster:
            insecure-skip-tls-verify: true
            server: https://${{ secrets.CONTROL_PLANE_IP }}:6443
          name: kubernetes
        contexts:
        - context:
            cluster: kubernetes
            user: kubernetes-admin
          name: kubernetes-admin@kubernetes
        current-context: kubernetes-admin@kubernetes
        kind: Config
        preferences: {}
        users:
        - name: kubernetes-admin
          user:
            token: ${{ secrets.KUBE_TOKEN }}
        EOF
        
        chmod 600 ~/.kube/config

    - name: Get service account token from control plane
      if: ${{ !env.KUBE_TOKEN }}
      uses: appleboy/ssh-action@v0.1.10
      with:
        host: ${{ secrets.CONTROL_PLANE_IP }}
        username: ubuntu
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Create a service account for GitHub Actions
          sudo kubectl --kubeconfig=/etc/kubernetes/admin.conf apply -f - << 'EOF'
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: github-actions
            namespace: kube-system
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: github-actions
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: cluster-admin
          subjects:
          - kind: ServiceAccount
            name: github-actions
            namespace: kube-system
          ---
          apiVersion: v1
          kind: Secret
          metadata:
            name: github-actions-token
            namespace: kube-system
            annotations:
              kubernetes.io/service-account.name: github-actions
          type: kubernetes.io/service-account-token
          EOF
          
          # Wait for token to be created
          sleep 10
          
          # Get the token
          sudo kubectl --kubeconfig=/etc/kubernetes/admin.conf get secret github-actions-token -n kube-system -o jsonpath='{.data.token}' | base64 -d
      id: get_token

    - name: Update kubeconfig with token
      if: ${{ steps.get_token.outputs.stdout }}
      run: |
        # Update kubeconfig with the actual token
        kubectl config set-credentials kubernetes-admin --token="${{ steps.get_token.outputs.stdout }}"

    - name: Test cluster connection
      run: |
        echo "=== Testing cluster connection ==="
        kubectl cluster-info
        kubectl get nodes
        kubectl get namespaces

    - name: Wait for cluster to be ready
      run: |
        echo "=== Waiting for all nodes to be ready ==="
        kubectl wait --for=condition=Ready nodes --all --timeout=300s

    - name: Install cert-manager
      run: |
        echo "=== Installing cert-manager ==="
        kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v1.13.0/cert-manager.yaml
        
        echo "=== Waiting for cert-manager to be available ==="
        kubectl wait --for=condition=available deployment/cert-manager -n cert-manager --timeout=300s
        kubectl wait --for=condition=available deployment/cert-manager-cainjector -n cert-manager --timeout=300s
        kubectl wait --for=condition=available deployment/cert-manager-webhook -n cert-manager --timeout=300s

    - name: Create namespaces
      run: |
        echo "=== Creating namespaces ==="
        kubectl apply -f k8s/namespaces/
        
        echo "=== Listing namespaces ==="
        kubectl get namespaces

    - name: Install metrics-server
      run: |
        echo "=== Installing metrics-server ==="
        kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
        
        # Patch metrics-server for development environments
        echo "=== Patching metrics-server ==="
        kubectl patch deployment metrics-server -n kube-system --type='json' -p='[
          {
            "op": "add",
            "path": "/spec/template/spec/containers/0/args/-",
            "value": "--kubelet-insecure-tls"
          }
        ]'
        
        echo "=== Waiting for metrics-server ==="
        kubectl wait --for=condition=available deployment/metrics-server -n kube-system --timeout=300s

    - name: Install Nginx Ingress Controller
      run: |
        echo "=== Installing Nginx Ingress Controller ==="
        kubectl apply -f k8s/nginx-ingress/
        
        echo "=== Waiting for Nginx Ingress Controller ==="
        kubectl wait --for=condition=available deployment/nginx-ingress-controller -n ingress-nginx --timeout=300s

    - name: Install ArgoCD
      run: |
        echo "=== Installing ArgoCD ==="
        kubectl create namespace argocd || true
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        
        echo "=== Waiting for ArgoCD server ==="
        kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=600s
        
        echo "=== Patching ArgoCD server for LoadBalancer ==="
        kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

    - name: Create cert-manager issuers
      run: |
        echo "=== Creating cert-manager issuers ==="
        kubectl apply -f k8s/cert-manager/

    - name: Install monitoring stack
      run: |
        echo "=== Installing monitoring stack ==="
        kubectl apply -f k8s/monitoring/prometheus/
        kubectl apply -f k8s/monitoring/grafana/
        
        echo "=== Waiting for monitoring components ==="
        kubectl wait --for=condition=available deployment/prometheus -n monitoring --timeout=300s
        kubectl wait --for=condition=available deployment/grafana -n monitoring --timeout=300s

    - name: Configure ArgoCD applications
      run: |
        echo "=== Configuring ArgoCD applications ==="
        sleep 60  # Wait for ArgoCD to be fully ready
        kubectl apply -f k8s/argocd/applications.yaml

    - name: Get access information
      run: |
        echo "=== Cluster Access Information ==="
        echo "Control Plane IP: ${{ secrets.CONTROL_PLANE_IP }}"
        echo "Kubernetes API: https://${{ secrets.CONTROL_PLANE_IP }}:6443"
        echo ""
        
        echo "=== Service Information ==="
        echo "ArgoCD Server:"
        kubectl get svc argocd-server -n argocd -o wide 2>/dev/null || echo "ArgoCD service not found"
        
        echo ""
        echo "Grafana Dashboard:"
        kubectl get svc grafana-service -n monitoring -o wide 2>/dev/null || echo "Grafana service not found"
        
        echo ""
        echo "Nginx Ingress Controller:"
        kubectl get svc ingress-nginx -n ingress-nginx -o wide 2>/dev/null || echo "Nginx Ingress service not found"
        
        echo ""
        echo "=== ArgoCD Admin Password ==="
        kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" 2>/dev/null | base64 -d || echo "ArgoCD password secret not found"
        echo ""
        
        echo ""
        echo "=== All Deployments ==="
        kubectl get deployments --all-namespaces
        
        echo ""
        echo "=== All Services ==="
        kubectl get services --all-namespaces