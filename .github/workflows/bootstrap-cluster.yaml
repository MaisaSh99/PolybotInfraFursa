name: Bootstrap Kubernetes Cluster

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Initialize Kubernetes Cluster"]
    types:
      - completed

jobs:
  bootstrap:
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Get and prepare kubeconfig from control plane
      uses: appleboy/ssh-action@v0.1.10
      with:
        host: ${{ secrets.CONTROL_PLANE_IP }}
        username: ubuntu
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          set -e  # Exit on any error
          
          echo "=== Checking if kubeconfig exists ==="
          if [ ! -f /home/ubuntu/.kube/config ]; then
            echo "Kubeconfig not found at /home/ubuntu/.kube/config"
            echo "Checking if cluster is initialized..."
            if [ -f /etc/kubernetes/admin.conf ]; then
              echo "Found admin.conf, copying to user directory..."
              mkdir -p /home/ubuntu/.kube
              sudo cp /etc/kubernetes/admin.conf /home/ubuntu/.kube/config
              sudo chown ubuntu:ubuntu /home/ubuntu/.kube/config
              echo "✅ Kubeconfig copied successfully"
            else
              echo "❌ ERROR: No kubeconfig found. Cluster may not be initialized."
              echo "Checking for kubeadm status..."
              sudo systemctl status kubelet || true
              ls -la /etc/kubernetes/ || true
              exit 1
            fi
          else
            echo "✅ Kubeconfig already exists"
          fi
          
          echo "=== Verifying kubeconfig file ==="
          if [ ! -s /home/ubuntu/.kube/config ]; then
            echo "❌ ERROR: Kubeconfig file is empty"
            exit 1
          fi
          echo "✅ Kubeconfig file has content ($(wc -c < /home/ubuntu/.kube/config) bytes)"
          
          echo "=== Original kubeconfig server address ==="
          grep "server:" /home/ubuntu/.kube/config || echo "No server line found"
          
          echo "=== Updating kubeconfig server address ==="
          # Replace localhost/127.0.0.1 with the actual control plane IP
          CONTROL_PLANE_IP="${{ secrets.CONTROL_PLANE_IP }}"
          echo "Using control plane IP: $CONTROL_PLANE_IP"
          sed -i "s|server: https://.*:6443|server: https://$CONTROL_PLANE_IP:6443|g" /home/ubuntu/.kube/config
          
          echo "=== Updated kubeconfig server address ==="
          grep "server:" /home/ubuntu/.kube/config
          
          echo "=== Testing local kubectl connection ==="
          kubectl get nodes --kubeconfig=/home/ubuntu/.kube/config || echo "Local kubectl test failed"
          
          echo "=== Encoding kubeconfig ==="
          echo "START_BASE64_KUBECONFIG"
          cat /home/ubuntu/.kube/config | base64 -w 0
          echo ""
          echo "END_BASE64_KUBECONFIG"
        script_stop: true
      id: get_kubeconfig

    - name: Debug SSH output
      run: |
        echo "=== SSH Step Output Length ==="
        echo "Length: ${#SSH_OUTPUT}"
        echo "First 200 chars:"
        echo "$SSH_OUTPUT" | head -c 200
        echo ""
        echo "Last 200 chars:"
        echo "$SSH_OUTPUT" | tail -c 200
        echo ""
      env:
        SSH_OUTPUT: ${{ steps.get_kubeconfig.outputs.stdout }}

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        
        # Extract just the base64 content between markers
        FULL_OUTPUT="${{ steps.get_kubeconfig.outputs.stdout }}"
        BASE64_CONTENT=$(echo "$FULL_OUTPUT" | sed -n '/START_BASE64_KUBECONFIG/,/END_BASE64_KUBECONFIG/p' | grep -v "START_BASE64_KUBECONFIG\|END_BASE64_KUBECONFIG")
        
        # Check if we extracted valid base64 content
        if [ -z "$BASE64_CONTENT" ]; then
          echo "ERROR: No base64 content found between markers"
          echo "Full SSH output:"
          echo "$FULL_OUTPUT"
          exit 1
        fi
        
        # Decode the base64 content
        echo "$BASE64_CONTENT" | base64 -d > ~/.kube/config
        
        # Check if file was created and has content
        if [ ! -f ~/.kube/config ]; then
          echo "ERROR: Kubeconfig file was not created"
          exit 1
        fi
        
        if [ ! -s ~/.kube/config ]; then
          echo "ERROR: Kubeconfig file is empty"
          echo "Base64 content was:"
          echo "$BASE64_CONTENT" | head -c 200
          exit 1
        fi
        
        chmod 600 ~/.kube/config
        
        echo "=== Kubeconfig file created successfully ==="
        echo "File size: $(wc -c < ~/.kube/config) bytes"

    - name: Debug kubeconfig
      run: |
        echo "=== Checking kubeconfig file ==="
        if [ -f ~/.kube/config ]; then
          echo "✅ Kubeconfig file exists"
          echo "File size: $(wc -c < ~/.kube/config) bytes"
          echo "File permissions: $(ls -la ~/.kube/config)"
        else
          echo "❌ Kubeconfig file does not exist"
          exit 1
        fi
        
        echo "=== Kubeconfig content (without certificates) ==="
        if grep -v "certificate-authority-data\|client-certificate-data\|client-key-data" ~/.kube/config; then
          echo "✅ Kubeconfig content displayed"
        else
          echo "❌ Failed to display kubeconfig content"
          echo "Raw file content:"
          cat ~/.kube/config || echo "Failed to cat file"
        fi
        
        echo "=== Testing cluster connection ==="
        kubectl cluster-info || echo "Cluster info failed"
        kubectl get nodes || echo "Get nodes failed"

    - name: Wait for cluster to be ready
      run: |
        echo "=== Waiting for nodes to be ready ==="
        kubectl wait --for=condition=Ready nodes --all --timeout=300s

    - name: Verify cluster is working
      run: |
        echo "=== Cluster verification ==="
        kubectl get nodes -o wide
        kubectl get pods --all-namespaces

    - name: Install cert-manager
      run: |
        echo "=== Installing cert-manager ==="
        kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v1.13.0/cert-manager.yaml
        kubectl wait --for=condition=available deployment/cert-manager -n cert-manager --timeout=300s
        kubectl wait --for=condition=available deployment/cert-manager-cainjector -n cert-manager --timeout=300s
        kubectl wait --for=condition=available deployment/cert-manager-webhook -n cert-manager --timeout=300s

    - name: Create namespaces
      run: |
        echo "=== Creating namespaces ==="
        kubectl apply -f k8s/namespaces/

    - name: Install metrics-server
      run: |
        echo "=== Installing metrics-server ==="
        kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
        # Patch metrics-server for development environments
        kubectl patch deployment metrics-server -n kube-system --type='json' -p='[
          {
            "op": "add",
            "path": "/spec/template/spec/containers/0/args/-",
            "value": "--kubelet-insecure-tls"
          }
        ]'
        kubectl wait --for=condition=available deployment/metrics-server -n kube-system --timeout=300s

    - name: Install Nginx Ingress Controller
      run: |
        echo "=== Installing Nginx Ingress Controller ==="
        kubectl apply -f k8s/nginx-ingress/
        kubectl wait --for=condition=available deployment/nginx-ingress-controller -n ingress-nginx --timeout=300s

    - name: Install ArgoCD
      run: |
        echo "=== Installing ArgoCD ==="
        # Install ArgoCD
        kubectl create namespace argocd || true
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        
        # Wait for ArgoCD to be ready
        kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=600s
        
        # Patch ArgoCD server for LoadBalancer access
        kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

    - name: Create cert-manager issuers
      run: |
        echo "=== Creating cert-manager issuers ==="
        kubectl apply -f k8s/cert-manager/

    - name: Install monitoring stack
      run: |
        echo "=== Installing monitoring stack ==="
        kubectl apply -f k8s/monitoring/prometheus/
        kubectl apply -f k8s/monitoring/grafana/
        
        # Wait for monitoring components
        kubectl wait --for=condition=available deployment/prometheus -n monitoring --timeout=300s
        kubectl wait --for=condition=available deployment/grafana -n monitoring --timeout=300s

    - name: Configure ArgoCD applications
      run: |
        echo "=== Configuring ArgoCD applications ==="
        # Wait a bit more for ArgoCD to be fully ready
        sleep 60
        
        # Apply ArgoCD applications
        kubectl apply -f k8s/argocd/applications.yaml

    - name: Get access information
      run: |
        echo "=== Cluster Access Information ==="
        echo "ArgoCD Server:"
        kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || \
        kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
        echo ""
        
        echo "Grafana Dashboard:"
        kubectl get svc grafana-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || \
        kubectl get svc grafana-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
        echo ""
        
        echo "Nginx Ingress Controller:"
        kubectl get svc ingress-nginx -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || \
        kubectl get svc ingress-nginx -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
        echo ""
        
        echo "ArgoCD Admin Password:"
        kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
        echo ""